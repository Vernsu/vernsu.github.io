<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Swift中值语义的实现 | Swift学徒</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是值语义目标对象由源对象拷贝生成，生成的目标对象与源对象彼此独立，改变互不影响。这就意味着，该对象的类型支持值语义。
从另一个角度来说，如果一个对象的值，只能由自己修改，则说明这个对象的类型支持值语义。
值语义的理解在OC中我们会经常这样写：
1@property(nonatomic,copy) NSString * verifyCode;
如果我们不这样写会导致什么问题？请看例子：
1234">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift中值语义的实现">
<meta property="og:url" content="http://yoursite.com/2017/01/19/001Swift中值语义的实现/index.html">
<meta property="og:site_name" content="Swift学徒">
<meta property="og:description" content="什么是值语义目标对象由源对象拷贝生成，生成的目标对象与源对象彼此独立，改变互不影响。这就意味着，该对象的类型支持值语义。
从另一个角度来说，如果一个对象的值，只能由自己修改，则说明这个对象的类型支持值语义。
值语义的理解在OC中我们会经常这样写：
1@property(nonatomic,copy) NSString * verifyCode;
如果我们不这样写会导致什么问题？请看例子：
1234">
<meta property="og:updated_time" content="2017-01-19T13:00:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift中值语义的实现">
<meta name="twitter:description" content="什么是值语义目标对象由源对象拷贝生成，生成的目标对象与源对象彼此独立，改变互不影响。这就意味着，该对象的类型支持值语义。
从另一个角度来说，如果一个对象的值，只能由自己修改，则说明这个对象的类型支持值语义。
值语义的理解在OC中我们会经常这样写：
1@property(nonatomic,copy) NSString * verifyCode;
如果我们不这样写会导致什么问题？请看例子：
1234">
  
    <link rel="alternate" href="/atom.xml" title="Swift学徒" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Swift学徒</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-001Swift中值语义的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/19/001Swift中值语义的实现/" class="article-date">
  <time datetime="2017-01-19T09:23:13.000Z" itemprop="datePublished">2017-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Swift中值语义的实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是值语义"><a href="#什么是值语义" class="headerlink" title="什么是值语义"></a>什么是值语义</h3><p>目标对象由源对象拷贝生成，生成的目标对象与源对象彼此独立，改变互不影响。这就意味着，该对象的类型支持值语义。</p>
<p>从另一个角度来说，如果一个对象的值，只能由自己修改，则说明这个对象的类型支持值语义。</p>
<h3 id="值语义的理解"><a href="#值语义的理解" class="headerlink" title="值语义的理解"></a>值语义的理解</h3><p>在OC中我们会经常这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,copy) NSString * verifyCode;</div></pre></td></tr></table></figure>
<p>如果我们不这样写会导致什么问题？请看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct Person &#123;</div><div class="line">    var name: NSString</div><div class="line">&#125;</div><div class="line"></div><div class="line">let name = NSMutableString()</div><div class="line">name.appendString(&quot;Bob&quot;)</div><div class="line">let bob = Person(name: name)</div><div class="line"></div><div class="line">name.appendString(&quot;, Jr.&quot;)</div><div class="line">let bobjr = Person(name: name)</div><div class="line"></div><div class="line">print(bob.name)</div><div class="line">print(bobjr.name)</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bob, Jr.</div><div class="line">Bob, Jr.</div></pre></td></tr></table></figure>
<p>原因在于：<code>NSString</code>是引用类型，它是不可变的，但是它有一个可变的子类：<code>NSMutableString</code>，导致<code>NSString</code>类型的<code>Property</code>实际上可能是<code>NSMutableString</code>类型。而我们要防止对象的属性被暗中修改。</p>
<p>同样的，在使用<code>NSURLRequest</code>以及集合类型时都需要进行防御性的拷贝。为此，OC语言为<code>Property</code>提供了一个<code>copy</code>属性。</p>
<p>但是，从性能和内存角度来考虑，防御性拷贝明显不是最优措施。</p>
<p>Swift 中的<code>String</code>是值类型,符合值语义，不会存在共享引用这个问题。</p>
<h3 id="Swift中值语义的实现"><a href="#Swift中值语义的实现" class="headerlink" title="Swift中值语义的实现"></a>Swift中值语义的实现</h3><h4 id="Case-1：原始值类型"><a href="#Case-1：原始值类型" class="headerlink" title="Case 1：原始值类型"></a>Case 1：原始值类型</h4><p>Swift 中标准值类型支持值语义，比如：<code>Int</code>，<code>String</code>，<code>Double</code>等。</p>
<h4 id="Case-2：复合的值类型"><a href="#Case-2：复合的值类型" class="headerlink" title="Case 2：复合的值类型"></a>Case 2：复合的值类型</h4><p>这里遵循一个简单的规则，如果一个 <code>Struct</code> 的所有 <code>Stored Property</code>  都支持值语义，则该<code>Struct</code>支持值语义。</p>
<h4 id="Case-3：引用类型"><a href="#Case-3：引用类型" class="headerlink" title="Case 3：引用类型"></a>Case 3：引用类型</h4><p>引用类型也可以有值语义。</p>
<p>改变引用类型变量的值有两种方式：</p>
<ol>
<li>给变量分配另一个实例。</li>
<li>修改实例自身。</li>
</ol>
<p>第一种方式是靠变量自身进行修改的，这是被值语义所允许的。而第二种方式可能是由其他变量的修改导致。</p>
<p>所以，如果要让一个引用类型拥有值语义，必须保证它的内部是不可变的。为了做到这点，需要让所有的 <code>Stored Property</code> 为常量。也就是说，在初始化后不会再被改变。</p>
<p><code>UIKit</code>中很多地方使用了这种模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = UIImage(named:&quot;smile.jpg&quot;)</div><div class="line">var b = a</div><div class="line">computeValue(b) // =&gt; something</div><div class="line">doSomething(a)</div><div class="line">computeValue(b) // =&gt; same thhing</div></pre></td></tr></table></figure>
<p>显而易见，<code>UIImage</code> 是引用类型，但是是不可变的。<code>doSomething(a)</code>不会导致<code>computeValue(b)</code>的返回结果有任何变化。</p>
<p><code>UIImage</code> 有很多 <code>Property</code>（<code>scale</code>，<code>capInset</code>，<code>renderimgmode</code>等），但是都是只读的，无法修改。所以一个变量没法影响另一个变量。</p>
<p>注意：如果其中一个<code>Property</code>不是常量，那就破坏了<code>UIImage</code>的值语义。</p>
<p>Cocoa 中有很多<code>Class</code>定义为不可变就是这个原因：不可变的引用类型拥有值语义。</p>
<h4 id="Case-4：值类型包含可变的引用类型"><a href="#Case-4：值类型包含可变的引用类型" class="headerlink" title="Case 4：值类型包含可变的引用类型"></a>Case 4：值类型包含可变的引用类型</h4><p>使用一个特殊的技巧可以使这种情况也可以拥有值语义，<code>Swift</code>标准库里大量使用了这种技术。<br>具体的实现下一篇文章会详细介绍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/19/001Swift中值语义的实现/" data-id="ciy4ds15j0000dopve0hnygjs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/19/001Swift中值语义的实现/">Swift中值语义的实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 万恶胖为首<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>