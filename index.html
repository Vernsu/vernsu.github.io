<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/rss.xml" title="Swift学徒" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="笨办法学Swift">
<meta property="og:type" content="website">
<meta property="og:title" content="Swift学徒">
<meta property="og:url" content="http://swift.diagon.me/index.html">
<meta property="og:site_name" content="Swift学徒">
<meta property="og:description" content="笨办法学Swift">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift学徒">
<meta name="twitter:description" content="笨办法学Swift">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://swift.diagon.me/"/>





  <title> Swift学徒 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2d1b9ca1ddd64ef2206b43ea10ec9d25";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Swift学徒</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">笨办法学Swift</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/AsyncDisplayKit-3/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/AsyncDisplayKit-3/" itemprop="url">
                  AsyncDisplayKit 教程(3)：TableNode
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-25T00:00:00+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本教程的初始工程 RainforestStarter 可以点<a href="https://koenig-media.raywenderlich.com/uploads/2016/12/AsyncDisplayKit-Starter-3.zip" target="_blank" rel="external">这里</a>获取。</p>
<p>运行程序，App 中包含了一个 UITableView，显示了一个野生动物的列表。滚动页面，帧率开始下降。这个 App 明显的需要进行性能上调优。</p>
<h3 id="用-TableNode-替换-Table-View"><a href="#用-TableNode-替换-Table-View" class="headerlink" title="用 TableNode 替换 Table View"></a>用 TableNode 替换 Table View</h3><p>在 AnimalTableController.m 中引入 AsyncDisplayKit：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>将 tableView 属性声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UITableView</span> *tableView;</div></pre></td></tr></table></figure>
<p>替换为 tableNode:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ASTableNode *tableNode;</div></pre></td></tr></table></figure>
<p>这会导致许多代码出现错误，这些错误会引导你去完成整个转换。</p>
<p>我们需要将所有的 tableView 实例修改为 tableNode，其中注意这些地方：</p>
<ol>
<li>将一个 ASTableNode 实例分配给 tableNode。</li>
<li>ASTableNode 对象没有 <code>registerCalss: forCellReuseIdentifier</code> 方法。</li>
<li>你不能将 node 添加为一个 subview。</li>
</ol>
<p>将 <code>viewDidLoad</code> 方法修改为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.tableNode = [[ASTableNode alloc]initWithStyle:<span class="built_in">UITableViewStylePlain</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view addSubnode:<span class="keyword">self</span>.tableNode];</div><div class="line">    [<span class="keyword">self</span> wireDelegation];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> applyStyle];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，我们调用它了 UIVIew 的 <code>addSubnode:</code> 方法，这个方法是通过 Category 的方式被添加到 UIView 上的。它实际上等于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.tableNode.view];</div></pre></td></tr></table></figure>
<p>修改 <code>viewWillLayoutSubviews</code> 方法，将 self.tableView 替换为 self.tableNode :</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews &#123;</div><div class="line">  [<span class="keyword">super</span> viewWillLayoutSubviews];</div><div class="line"></div><div class="line">  <span class="keyword">self</span>.tableNode.frame = <span class="keyword">self</span>.view.bounds;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改 <code>applyStyle</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applyStyle &#123;</div><div class="line">  <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">  <span class="keyword">self</span>.tableNode.view.separatorStyle = <span class="built_in">UITableViewCellSeparatorStyleNone</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了设置 tableView 的 separatorStyle 属性，我们必须访问 tableNode 的 view 属性。ASTableNode 并没有将 UITableView 的所有属性都暴露出来，因此为了访问 UITableView 的某些属性，你必须访问位于 TableNode 底下的 UITableView 对象。</p>
<h3 id="设置-TableNote-的-Data-Source-amp-Delegate"><a href="#设置-TableNote-的-Data-Source-amp-Delegate" class="headerlink" title="设置 TableNote 的 Data Source &amp; Delegate"></a>设置 TableNote 的 Data Source &amp; Delegate</h3><p>和 UITableView 一样，ASTableNode 也有 Data Source 和 Delegate。TableNode 的 ASTableDataSource 和 ASTableDelegate 协议和 UITableViewDataSource 和 UITableViewDelegate 协议非常相似。</p>
<p>将 <code>wireDelegation</code>方法中的 tableView 修改为 tableNode</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)wireDelegation &#123;</div><div class="line">  <span class="keyword">self</span>.tableNode.dataSource = <span class="keyword">self</span>;</div><div class="line">  <span class="keyword">self</span>.tableNode.delegate = <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且让 controller 遵守 ASTableDataSource 和 ASTableDelegate 协议。</p>
<h4 id="实现-ASTableDataSource-协议"><a href="#实现-ASTableDataSource-协议" class="headerlink" title="实现 ASTableDataSource 协议"></a>实现 ASTableDataSource 协议</h4><p>首先，将 UITableViewDataSource 方法 <code>tableView:numberOfRowsInSection:</code> 修改为 ASTableDataSource 协议的版本。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)tableNode:(ASTableNode *)tableNode numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.animals.count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，ASTableNodes 返回 cell 的方式和 UITableView 有所不同。将 <code>tableView:cellForRowAtIndexPath:</code>方法替换为:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1</span></div><div class="line">- (ASCellNodeBlock)tableNode:(ASTableView *)tableView nodeBlockForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  <span class="comment">//2</span></div><div class="line">  RainforestCardInfo *animal = <span class="keyword">self</span>.animals[indexPath.row];</div><div class="line"></div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="keyword">return</span> ^&#123;</div><div class="line">    <span class="comment">//4</span></div><div class="line">    CardNode *cardNode = [[CardNode alloc] initWithAnimal:animal];</div><div class="line"></div><div class="line">    <span class="comment">//You'll add something extra here later...</span></div><div class="line">    <span class="keyword">return</span> cardNode;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码解释：</p>
<ol>
<li>ASCellNode 等价于 UITableViewCell 或 UICollectionViewCell。注意这个方法返回的是一个 ASCellNodeBlock。因为一个 ASTableNode 在内部维护了所有的 cell，为每个 cell 的 Index Path 指定了一个 block，这样就能够并发的初始化所有的 cell。</li>
<li>得到一个数据模型对象。闭包会捕捉到这个对象。IndexPath 不需要在闭包中使用，有可能在闭包调用前数据会发生改变。</li>
<li>闭包中返回的类型必须是 ASCellNode。</li>
<li>不需要关心 cell 重用的问题，因此只需要实例化一个 cell。注意，你返回的是一个 CardNode 而不是 CardCell。</li>
</ol>
<h4 id="实现-ASTableDelegate-协议"><a href="#实现-ASTableDelegate-协议" class="headerlink" title="实现 ASTableDelegate 协议"></a>实现 ASTableDelegate 协议</h4><p>在使用 UITableView 的时候通常都需要实现 <code>tableView:heightForRowAtIndexPath:</code> 方法来计算每个 cell 的高度。</p>
<p>ASTableDelegate 中没有 <code>tableView:heightForRowAtIndexPath:</code> 方法。如果使用 ASDK, 所有的 ASCellNodes 都自己负责计算它们的大小。不需要提供一个固定的高度，你可以为每个 cell 指定一个最大尺寸和最小尺寸。这个例子中，你需要让每个 cell 至少占据屏幕 2/3 的高度。</p>
<p>将 -tableView:heightForRowAtIndexPath: 方法替换为:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-(ASSizeRange)tableNode:(ASTableNode *)tableNode constrainedSizeForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGFloat</span> width = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width;</div><div class="line">    <span class="built_in">CGSize</span> min = <span class="built_in">CGSizeMake</span>(width, ([<span class="built_in">UIScreen</span> mainScreen].bounds.size.height/<span class="number">3</span>) * <span class="number">2</span>);</div><div class="line">    <span class="built_in">CGSize</span> max = <span class="built_in">CGSizeMake</span>(width, INFINITY);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> ASSizeRangeMake(min, max);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>搞定！ 运行一下，很流畅~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/AsyncDisplayKit-2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/AsyncDisplayKit-2/" itemprop="url">
                  AsyncDisplayKit 教程(2)：ASDisplayNode
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T00:00:00+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ASDisplayNode"><a href="#ASDisplayNode" class="headerlink" title="ASDisplayNode"></a>ASDisplayNode</h2><p>ASDisplayNode 是 ASDK 的核心类。</p>
<p>我们知道 UIView 是对 CALayer 的一个封装，添加了触摸事件的处理以及其他功能。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fd2tzeu6aej30i208mq3r.jpg" alt=""></p>
<p>ASDisplayNode 也使用了这种抽象。你可以认为 Node 包含了一个 View，就像 View 包含了一个 Layer。</p>
<p>Node 可以在后台队列中创建和配置，默认情况使用异步渲染。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fd2u1q81jbj30qo08ymx8.jpg" alt=""></p>
<p>Node 的 API 和 UIView 的难以置信的相似：所有的 View 属性都可以在 node 上找到相同的。你还可访问底层的 view 或 layer，就像你可以访问 UIView的 .layer 一样。</p>
<h2 id="Node-Containers"><a href="#Node-Containers" class="headerlink" title="Node Containers"></a>Node Containers</h2><p>Node 与四个容器类中的一个结合使用时，就产生魔法般的性能提升。</p>
<p>这四个类包含：</p>
<ul>
<li>ASViewController:  UIViewController 子类，允许你创建节点并进行管理。</li>
<li>ASCollectionNode 和 ASTableNode:  UICollectionView 和 UITableView 对应的 Node 类。</li>
<li>ASPagerNode:  ASCollectionNode 子类，和 UIPageViewController 相比，提供了很棒的 swiping 性能。</li>
</ul>
<p>真正的魔法来自于： ASRangeController，这 4 个类都会通过它来影响所包含的 node 的行为。这个后面再讲。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/AsyncDisplayKit-1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/AsyncDisplayKit-1/" itemprop="url">
                  AsyncDisplayKit 教程(1)：介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-23T00:00:00+08:00">
                2017-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文翻译改编自 ray 的<a href="https://www.raywenderlich.com/124311/asyncdisplaykit-2-0-tutorial-getting-started" target="_blank" rel="external">《AsyncDisplayKit 2.0 Tutorial: Getting Started》</a>。</p>
<p>AsyncDisplayKit 是一个 UI 框架，源自 Facebook 的 Paper。它解决了 Paper 团队面临的一个核心问题：如何让主线程尽可能地保持简洁？ </p>
<p>用户界面完全依赖于主线程，并且对主线程的延迟非常敏感。主线程阻塞意味着掉帧，并导致用户体验很差。</p>
<p>主线程进行的高消耗操作包括：</p>
<ul>
<li>尺寸计算和视图布局：比如，<code>heightForRowAtIndexPath</code>方法，或者对 UILabel 调用 <code>sizeThatFits</code>方法。以及大量 AutoLayout 约束计算。</li>
<li>图片解码：在一个 UIImageView 中使用 UIImage，意味着首先要进行图片数据的解码。</li>
<li>文本渲染：复杂文本的渲染。</li>
<li>图形绘制：手动绘制渐变色和阴影。</li>
<li>对象生命周期：创建、操作和销毁系统对象（比如创建一个 UIView）。</li>
</ul>
<p>AsyncDisplayKit 默认允许异步的进行尺寸计算，视图布局，Rendering（文本渲染、图形绘制、图片解码）操作。这样就大量的减轻了主线程的负担。</p>
<p>AsyncDisplayKit 支持 Objective-C 与 Swift，但是不支持 Interface Builder 与 AutoLayout。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/UIView-Animation-getting-start/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/UIView-Animation-getting-start/" itemprop="url">
                  UIView Animation 1：基础动画效果
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-22T00:00:00+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS动画/" itemprop="url" rel="index">
                    <span itemprop="name">iOS动画</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UIView Animation 是被设计来让开发者更简单的创建动画效果，避免使用复杂的 Core Animation。</p>
<p>本文将介绍 UIView Animation 的常用 API。</p>
<p>下图是一个普通的登录页面：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fczhze1z9zj30ac0a1gm6.jpg" alt=""></p>
<h2 id="第一个动画"><a href="#第一个动画" class="headerlink" title="第一个动画"></a>第一个动画</h2><p>第一个动画效果是当用户打开 app 时，页面的 UI 元素从屏幕外移动到屏幕内。</p>
<p>在<code>viewWillAppear</code>中,将这几个元素移出屏幕：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">heading.center.x  -= view.bounds.width</div><div class="line">username.center.x -= view.bounds.width</div><div class="line">password.center.x -= view.bounds.width</div></pre></td></tr></table></figure>
<p>目前这几个元素的位置相当于在当前屏幕左侧新建了一个对称屏幕中的位置。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fczilnuiebj30ac0baq3c.jpg" alt=""></p>
<p>现在可以在页面显示后，将这几个元素移动回原位置，为了避免所有元素同步显示显得呆板，可以设置显示的先后顺序。在<code>viewDidAppear</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>) &#123;</div><div class="line">    <span class="keyword">self</span>.heading.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.3</span>, options: [], animations: &#123; </div><div class="line">    <span class="keyword">self</span>.username.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div><div class="line">    </div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.4</span>, options: [], animations: &#123; </div><div class="line">    <span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p><code>option</code> 是一组自定义的选项，这里先传入<code>[]</code>，表示没有特殊选项。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fczj8hdmz6g30a309cwfb.gif" alt=""></p>
<h2 id="可以添加动画的属性"><a href="#可以添加动画的属性" class="headerlink" title="可以添加动画的属性"></a>可以添加动画的属性</h2><p>不是所有的 UIView 属性都可以添加动画，以下是可以使用动画的属性。</p>
<h3 id="位置和大小"><a href="#位置和大小" class="headerlink" title="位置和大小"></a>位置和大小</h3><p>对视图位置和大小的修改可以产生扩张，收缩，移动效果。以下是相关的属性：</p>
<ul>
<li>bounds：在视图的 frame 中重新安排视图的内容的位置</li>
<li>frame：移动或缩放视图</li>
<li>center：移动视图到新位置</li>
</ul>
<p>你可以修改这些属性或者这些属性的成员。比如通过 <code>center.y</code> 改变竖直位置，通过<code>frame.size.width</code>来缩放。</p>
<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>可以改变视图的背景色或透明度。</p>
<ul>
<li>backgroundColor</li>
<li>alpha：可以制造淡入淡出的效果。</li>
</ul>
<p>对云朵使用淡入动画:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.5</span>, options: [], animations: &#123;</div><div class="line">    <span class="keyword">self</span>.cloud1.alpha = <span class="number">1.0</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.7</span>, options: [], animations: &#123;</div><div class="line">    <span class="keyword">self</span>.cloud2.alpha = <span class="number">1.0</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.9</span>, options: [], animations: &#123;</div><div class="line">    <span class="keyword">self</span>.cloud3.alpha = <span class="number">1.0</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">1.0</span>, options: [], animations: &#123;</div><div class="line">    <span class="keyword">self</span>.cloud4.alpha = <span class="number">1.0</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1fczm9miadhg30a30dkdhq.gif" alt=""></p>
<h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><ul>
<li>transform： 旋转，缩放</li>
</ul>
<p>底层是仿射变换。可以使用跟强大的缩放因子和旋转角度，而不是详细的 bounds 和  center。</p>
<h2 id="动画选项"><a href="#动画选项" class="headerlink" title="动画选项"></a>动画选项</h2><p>接下来我们了解之前提到的 <code>option</code>。<code>UIViewAnimationOptions</code>罗列了所有的<code>option</code>，可以通过组合不同的<code>option</code>。</p>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><ul>
<li>.repeat 包含这个选项可以使动画永远重复</li>
<li>.autoreverse 这个选项只能和 <code>.repeat</code>组合起来用。让你的动画先正向播放，再逆向播放。</li>
</ul>
<p>修改代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.4</span>,</div><div class="line">               options: .<span class="keyword">repeat</span>,</div><div class="line">               animations: &#123;</div><div class="line">                <span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">                &#125;,</div><div class="line">               completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1fczllm4fjqg30a309cta9.gif" alt=""></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.4</span>,</div><div class="line">               options: [.<span class="keyword">repeat</span>,.autoreverse] ,</div><div class="line">               animations: &#123;</div><div class="line">                <span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">                &#125;,</div><div class="line">               completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fczllqhd5ng30a309cmyw.gif" alt=""></p>
<p>注意 swift 为了方便使用，在只有一个 <code>option</code> 时 允许不将其放在 <code>[]</code> 中。</p>
<h3 id="动画缓动（Animation-easing）"><a href="#动画缓动（Animation-easing）" class="headerlink" title="动画缓动（Animation easing）"></a>动画缓动（Animation easing）</h3><p>物理世界的运动不一直是匀速的，不仅速度是变动的，而且加速度也是变动的。<br>常用的 easing option：</p>
<ul>
<li>.curveLinear： 用于没有加速度的动画。</li>
<li>.curveEaseIn： 用于开始时加速。</li>
<li>.curveEaseOut： 用于结束时减速。</li>
<li>.curveEaseInOut： 用于开始时加速，结束时减速。</li>
</ul>
<hr>
<div style="text-align: center"><br>关注公众号（ID：SwiftBetter），进一步探讨主题<br><br><br>每日精选高清题图，可做壁纸<br></div><br><div style="text-align: center"><br><img src="https://vernsu.github.io/images/wxqrcode.jpg" style="text-align: center;display: block;margin:auto;"><br></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/swift-enum-associated-values/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/swift-enum-associated-values/" itemprop="url">
                  Swift 中枚举的关联值
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-21T00:00:00+08:00">
                2017-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="枚举关联值与值绑定模式"><a href="#枚举关联值与值绑定模式" class="headerlink" title="枚举关联值与值绑定模式"></a>枚举关联值与值绑定模式</h2><p>当枚举的关联值和值绑定模式结合起来，就能够达到从枚举中取得关联值的效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Organism</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> plant</div><div class="line">  <span class="keyword">case</span> animal(legs: <span class="type">Int</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> pet = <span class="type">Organism</span>.animal(legs: <span class="number">4</span>)</div><div class="line"></div><div class="line"><span class="keyword">switch</span> pet &#123;</div><div class="line"><span class="keyword">case</span> .animal(<span class="keyword">let</span> legs):</div><div class="line">  <span class="built_in">print</span>(<span class="string">" <span class="subst">\(legs)</span> 条腿的动物"</span>) <span class="comment">// Printed: 4 条腿的动物</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">  <span class="built_in">print</span>(<span class="string">"植物"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中，.animal 的关联值是一个叫 legs 的常量。怎么把关联的值取出来？使用值绑定模式即可取出值。定义一个局部变量，名字可以随便取(不一定是 legs)，这个局部变量会和关联值连接起来。</p>
<h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p>optional 就是用 enum 实现的。</p>
<ol>
<li>.none 意味着没有值</li>
<li>.some 意味着有值，即有一个关联值</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age: <span class="type">Int</span>?</div><div class="line">age = <span class="number">17</span></div><div class="line"><span class="comment">//age = nil</span></div><div class="line"></div><div class="line"><span class="keyword">switch</span> age &#123;</div><div class="line"><span class="keyword">case</span> .<span class="keyword">none</span>:</div><div class="line">  <span class="built_in">print</span>(<span class="string">"No value"</span>)</div><div class="line"><span class="keyword">case</span> .some(<span class="keyword">let</span> value):</div><div class="line">  <span class="built_in">print</span>(<span class="string">"Got a value: <span class="subst">\(value)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>swift 中 nil 中其实就是 .none。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> optionalNil: <span class="type">Int</span>? = .<span class="keyword">none</span></div><div class="line"></div><div class="line">optionalNil == <span class="literal">nil</span>    <span class="comment">// true</span></div><div class="line">optionalNil == .<span class="keyword">none</span>  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<hr>
<div style="text-align: center"><br>关注公众号（ID：SwiftBetter），进一步探讨主题<br><br><br>每日精选高清题图，可做壁纸<br></div><br><div style="text-align: center"><br><img src="https://vernsu.github.io/images/wxqrcode.jpg" style="text-align: center;display: block;margin:auto;"><br></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/swift-pattern-matching-value-binding-pattern-identifier-pattern/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/swift-pattern-matching-value-binding-pattern-identifier-pattern/" itemprop="url">
                  Swift 模式匹配之标识符模式与值绑定模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-20T00:00:00+08:00">
                2017-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="值绑定模式（Value-Binding-Pattern）"><a href="#值绑定模式（Value-Binding-Pattern）" class="headerlink" title="值绑定模式（Value-Binding Pattern）"></a>值绑定模式（Value-Binding Pattern）</h2><p>值绑定模式是指把匹配到的值绑定给一个变量或常量。你能够在接下来的代码块中使用该变量/常量的值。把匹配到的值绑定给变量时，用关键字 var，绑定给常量时，用关键字 let。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let coordinate = (x: 1, y: 0, z: 0)</div><div class="line"></div><div class="line">if case (let x, 0, 0) = coordinate &#123;</div><div class="line">  print(“x坐标为 \(x)") //  1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 case 匹配 x 坐标为任意值，y，z为0。然后名为 x 的常量绑定了元组 x 部分的值。相当于你告诉编译器，从(something，0，0)中找到一个值时，分配something给x。</p>
<p>如果要绑定多个值，声明多个就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if case let (x, y, 0) = coordinate &#123;</div><div class="line">  print(“x,y分别是(\(x), \(y))&quot;) //  1, 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将let移到元组外边，编译器能够绑定所有的常量。这个例子中，let 会分配到元组模式 (x, y, z) 中的各个标识符模式。因此，switch 语句中 case let (x, y ,0): 和 case (let x, let y, 0): 的匹配效果是一样的。</p>
<h2 id="标识符模式-（Identifier-Pattern）"><a href="#标识符模式-（Identifier-Pattern）" class="headerlink" title="标识符模式 （Identifier Pattern）"></a>标识符模式 （Identifier Pattern）</h2><p>标识符模式是值绑定模式的子模式。标识符模式是常量或者变量的名称自身。例如，在下面的常量声明中，someValue 是一个标识符模式，匹配了 Int 类型的 42：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> someValue = <span class="number">42</span></div></pre></td></tr></table></figure>
<p>当匹配成功时，42 被绑定（赋值）给常量 someValue。</p>
<h2 id="在值绑定模式中的标识符模式会把新命名的变量或常量与匹配到的值做绑定。例如，你可以拆开一个元组，然后把每个元素绑定到相应的标识符模式中。"><a href="#在值绑定模式中的标识符模式会把新命名的变量或常量与匹配到的值做绑定。例如，你可以拆开一个元组，然后把每个元素绑定到相应的标识符模式中。" class="headerlink" title="在值绑定模式中的标识符模式会把新命名的变量或常量与匹配到的值做绑定。例如，你可以拆开一个元组，然后把每个元素绑定到相应的标识符模式中。"></a>在值绑定模式中的标识符模式会把新命名的变量或常量与匹配到的值做绑定。例如，你可以拆开一个元组，然后把每个元素绑定到相应的标识符模式中。</h2><div style="text-align: center"><br>关注公众号（ID：SwiftBetter），进一步探讨主题<br><br><br>每日精选高清题图，可做壁纸<br></div><br><div style="text-align: center"><br><img src="https://vernsu.github.io/images/wxqrcode.jpg" style="text-align: center;display: block;margin:auto;"><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/iOS-cornerRadius-masksToBounds-CALayer/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/iOS-cornerRadius-masksToBounds-CALayer/" itemprop="url">
                  iOS 中 masksToBounds 与 layer’s contents
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-19T00:00:00+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="masksToBounds"><a href="#masksToBounds" class="headerlink" title="masksToBounds"></a>masksToBounds</h3><p>在<a href="http://swift.diagon.me/cornerRadius/">《iOS 性能优化之视图圆角》</a>中提到同时使用 <code>cornerRadius</code> 和 <code>maskToBounds</code> 会触发离屏渲染。</p>
<p>如果你给 UIImageView 设置圆角，会发现只需要设置 <code>cornerRadius</code>，就可以完成圆角效果，那 <code>masksToBounds</code> 是做什么的？</p>
<p>查看 <code>cornerRadius</code> 的文档：</p>
<blockquote>
<p>Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners.</p>
</blockquote>
<p>说明 <code>cornerRadius</code> 设置的圆角只对背景色和图层边框有用，对 <code>layer</code> 的 <code>contents</code> 属性中的 <code>image</code> 无效。当 <code>contents</code> 有内容或者内容背景不是透明的时，单靠 <code>cornerRadius</code> 是无法完成圆角效果的（比如说 UILabel ）。所以才要设置 <code>masksToBounds</code> 为 <code>true</code> (在 UIView 上对应的属性是 <code>clipsToBounds</code>，在 IB 里对应的设置是「Clip Subiews」选项)。<code>masksToBounds</code> 会裁剪 <code>layer</code>的 <code>contents</code>。</p>
<h3 id="layer’s-contents"><a href="#layer’s-contents" class="headerlink" title="layer’s contents"></a>layer’s contents</h3><p>CALayer 有一个 <code>contents</code> 属性，这个属性的类型被定义为 id，意味着它可以是任何类型的对象。但是，在实践中，如果 <code>contents</code> 不是 CGImage，那么图层将是空白。</p>
<p>UIImage 有一个 cgImage 属性，我们把 layerView 图层的 contents 属性设置成图片。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layerView.layer.contents = <span class="type">UIImage</span>(named: <span class="string">"image"</span>)?.cgImage</div></pre></td></tr></table></figure>
<p>我们利用 CALayer 在一个普通的 UIView 中显示了一张图片。</p>
<hr>
<div style="text-align: center"><br>关注公众号（ID：SwiftBetter），进一步探讨主题<br><br><br>每日精选高清题图，可做壁纸<br></div><br><div style="text-align: center"><br><img src="https://vernsu.github.io/images/wxqrcode.jpg" style="text-align: center;display: block;margin:auto;"><br></div>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/iOS-Swift-HTTP-TCP-IP-WebSocket-Socket/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/iOS-Swift-HTTP-TCP-IP-WebSocket-Socket/" itemprop="url">
                  iOS 客户端开发需要掌握的 HTTP 知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-18T00:00:00+08:00">
                2017-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：本文内容总结自《图解HTTP》一书。</p>
<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="使用-HTTP-访问-Web"><a href="#使用-HTTP-访问-Web" class="headerlink" title="使用 HTTP 访问 Web"></a>使用 HTTP 访问 Web</h3><p>在浏览器中输入域名并按下回车，发生了什么事情？这是一个古老的问题。详细的答案请点<a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external">这里</a>。<br>简单的说就是浏览器根据 URL 从服务器获取了文件资源等信息，从而显示出 Web 页面。而其间完成从客户端到服务端之间运作流程的协议即 HTTP。</p>
<h3 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h3><h4 id="TCP-IP-是什么"><a href="#TCP-IP-是什么" class="headerlink" title="TCP/IP 是什么"></a>TCP/IP 是什么</h4><p>TCP/IP 是互联网相关的各类协议集合起来的总称。比如包含DNS，IP，PPPoE，UDP，FTP，HTTP，TCP，ICMP等等。</p>
<h4 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h4><p>TCP/IP 协议族按层次分为4层：应用层、传输层、网络层和数据链路层。这样做的意义是：如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。而对应的层次只需要考虑到自己的任务即可。</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。（FTP，DNS，HTTP）</li>
<li>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。（TCP、UDP）</li>
<li>网络层：用来处理在网络上流动的数据包。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。（IP）</li>
<li>链路层（又名数据链路层）：用来处理连接网络的硬件部分。</li>
</ul>
<h4 id="通信传输流"><a href="#通信传输流" class="headerlink" title="通信传输流"></a>通信传输流</h4><p>进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<h3 id="与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议：IP、TCP 和 DNS</h3><h4 id="负责数据包传送的-IP"><a href="#负责数据包传送的-IP" class="headerlink" title="负责数据包传送的 IP"></a>负责数据包传送的 IP</h4><p>IP 协议的作用是把各种数据包传送给对方。涉及到 IP 地址、MAC 地址。</p>
<h4 id="确保可靠性的-TCP"><a href="#确保可靠性的-TCP" class="headerlink" title="确保可靠性的 TCP"></a>确保可靠性的 TCP</h4><p>TCP 将 HTTP 请求报文分割成报文段，把每个报文段可靠的传给对方。</p>
<p>为了准确无误地将每个报文段送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。</p>
<p>用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志 —— SYN 和 ACK。</p>
<p>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<h4 id="负责域名解析的-DNS"><a href="#负责域名解析的-DNS" class="headerlink" title="负责域名解析的 DNS"></a>负责域名解析的 DNS</h4><p>它提供域名到 IP 地址之间的解析服务。</p>
<h2 id="HTTP-基础"><a href="#HTTP-基础" class="headerlink" title="HTTP 基础"></a>HTTP 基础</h2><h3 id="HTTP-用于客户端和服务端之间的通信"><a href="#HTTP-用于客户端和服务端之间的通信" class="headerlink" title="HTTP 用于客户端和服务端之间的通信"></a>HTTP 用于客户端和服务端之间的通信</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
<p>客户端发出的请求报文是由请求方法(GET等)、请求 URI（在首部指定Host就不需要绝对地址了）、协议版本（HTTP1.1）、请求首部字段和内容实体构成的。</p>
<p>服务端的响应报文由协议版本、状态码、用以解释状态码的原因短语(OK)、响应首部字段以及内容实体构成。</p>
<h3 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。</p>
<p>比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。HTTP/1.1 虽然是无状态协议，为了实现保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>
<h3 id="告知服务器意图的-HTTP-方法"><a href="#告知服务器意图的-HTTP-方法" class="headerlink" title="告知服务器意图的 HTTP 方法"></a>告知服务器意图的 HTTP 方法</h3><ul>
<li>GET 获取资源</li>
<li>POST 传输内容实体</li>
<li>PUT 传输文件（需配合验证机制）</li>
<li>HEAD 获得报文头部</li>
<li>DELETE 删除文件（需配合验证机制）</li>
<li>OPTIONS 询问支持的方法</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>
<p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h2 id="HTTP-报文中的-HTTP-信息"><a href="#HTTP-报文中的-HTTP-信息" class="headerlink" title="HTTP 报文中的 HTTP 信息"></a>HTTP 报文中的 HTTP 信息</h2><h3 id="压缩传输的内容编码，提升传输速率"><a href="#压缩传输的内容编码，提升传输速率" class="headerlink" title="压缩传输的内容编码，提升传输速率"></a>压缩传输的内容编码，提升传输速率</h3><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br>常用的内容编码有以下几种：</p>
<ol>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ol>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p>
<p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需求进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul>
<li>200 OK：表示从客户端发来的请求在服务器端被正常处理了</li>
<li>206 Partial Content：请求处理成功，返回部分内容，响应报文中包含 Content-Range 指定范围的实体内容</li>
</ul>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul>
<li>301 Moved Permanently：永久性重定向。表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>
<li>302 Found：临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。已移动的资源对应的 URI 将来还有可能发生改变。</li>
<li>304 Not Modified：表示请求的资源没有改变，可以使用客户端上未过期的资源 </li>
</ul>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul>
<li>400 Bad Request：表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li>
<li>403 Forbidden：表示请求资源的访问被服务器拒绝了。</li>
<li>404 Not Found：表示服务器上没有请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li>
</ul>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul>
<li><p>500 Internal Server Error：表示服务器在执行请求时发生了错误。</p>
</li>
<li><p>503 Service Unavailable：表示服务器暂时处于超负载或者正在进行停机维护，现在无法处理请求</p>
</li>
</ul>
<h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
</tbody>
</table>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
<td>Accept: text/html,application/xml</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
<td>Accept-Encoding: gzip, deflate </td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言</td>
<td>Accept-Language: zh-cn,zh;q=0.7 </td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
<td>Host: swift.diagon.me</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
<td>User-Agent: Mozilla/5.0 </td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
</tbody>
</table>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTP-安全隐患"><a href="#HTTP-安全隐患" class="headerlink" title="HTTP 安全隐患"></a>HTTP 安全隐患</h3><h4 id="通信使用明文（不加密），内容可能会被窃听"><a href="#通信使用明文（不加密），内容可能会被窃听" class="headerlink" title="通信使用明文（不加密），内容可能会被窃听"></a>通信使用明文（不加密），内容可能会被窃听</h4><h5 id="加密处理防止窃听"><a href="#加密处理防止窃听" class="headerlink" title="加密处理防止窃听"></a>加密处理防止窃听</h5><h6 id="通信的加密"><a href="#通信的加密" class="headerlink" title="通信的加密"></a>通信的加密</h6><p>HTTP 协议中没有加密机制，但可以通过 SSL（Secure Socket Layer，安全套接层），加密 HTTP 的通信线路。</p>
<p>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS。</p>
<h6 id="内容加密"><a href="#内容加密" class="headerlink" title="内容加密"></a>内容加密</h6><p>由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。</p>
<p>在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。</p>
<p>有一点必须引起注意，由于该方式不同于 SSL 将整个通信线路加密处理，所以内容仍有被篡改的风险。</p>
<h4 id="不验证通信方的身份，因此有可能遭遇伪装"><a href="#不验证通信方的身份，因此有可能遭遇伪装" class="headerlink" title="不验证通信方的身份，因此有可能遭遇伪装"></a>不验证通信方的身份，因此有可能遭遇伪装</h4><h5 id="任何人都可以发起请求"><a href="#任何人都可以发起请求" class="headerlink" title="任何人都可以发起请求"></a>任何人都可以发起请求</h5><ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击。</li>
</ul>
<h5 id="查明对手的证书"><a href="#查明对手的证书" class="headerlink" title="查明对手的证书"></a>查明对手的证书</h5><p>SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定对方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。</p>
<h4 id="无法证明报文的完整性，所以有可能已遭篡改"><a href="#无法证明报文的完整性，所以有可能已遭篡改" class="headerlink" title="无法证明报文的完整性，所以有可能已遭篡改"></a>无法证明报文的完整性，所以有可能已遭篡改</h4><h5 id="接收到的内容可能有误"><a href="#接收到的内容可能有误" class="headerlink" title="接收到的内容可能有误"></a>接收到的内容可能有误</h5><p>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击</p>
<h5 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h5><p>SSL 提供认证和加密处理及摘要功能。”</p>
<h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP + 加密 + 认证 + 完整性保护 = HTTPS"></a>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</h3><h4 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h4><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p>
<p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 均可配合 SSL协议使用。SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<h4 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h4><p>SSL 采用一种叫做公开密钥加密的加密处理方式。近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。</p>
<p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p>
<h5 id="对称密钥加密的困境"><a href="#对称密钥加密的困境" class="headerlink" title="对称密钥加密的困境"></a>对称密钥加密的困境</h5><p>加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。即加密解密用同样的密钥。</p>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<h5 id="使用两把密钥的公开（非对称）密钥加密"><a href="#使用两把密钥的公开（非对称）密钥加密" class="headerlink" title="使用两把密钥的公开（非对称）密钥加密"></a>使用两把密钥的公开（非对称）密钥加密</h5><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走</p>
<h5 id="HTTPS-采用混合加密机制"><a href="#HTTPS-采用混合加密机制" class="headerlink" title="HTTPS 采用混合加密机制"></a>HTTPS 采用混合加密机制</h5><p>公开密钥加密与对称密钥加密相比，其处理速度要慢。所以 HTTPS 使用公开密钥的方式安全的交换了稍后对称加密中会使用的密钥，之后的建立通信交换报文阶段则使用对称密钥加密方式。</p>
<h4 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h4><p>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和颁发的公开密钥证书。</p>
<ol>
<li>服务器方向数字证书认证机构提交公开密钥。</li>
<li>数字证书认证机构在判明提出申请者的身份之后，会用自己的私有密钥对服务器方的公开密钥做数字签名，并向网站方颁发公钥证书。</li>
<li>服务器方会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</li>
<li>接到证书的客户端可使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名。一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。</li>
<li>使用服务器的公开密钥对报文进行加密后发送。</li>
<li>服务器使用私有密钥对报文解密。</li>
</ol>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>
<h2 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h2><h3 id="HTTP-瓶颈"><a href="#HTTP-瓶颈" class="headerlink" title="HTTP 瓶颈"></a>HTTP 瓶颈</h3><p>为了尽可能实时地显示更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。</p>
<p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>
<h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”的步骤。</p>
<ul>
<li>握手·请求：为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手的目的。</li>
<li>握手·响应：对于之前的请求，返回状态码101 Switching Protocols 的响应。</li>
</ul>
<p>成功握手确立WebSocket连接后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。</p>
<hr>
<div style="text-align: center"><br>关注公众号（ID：SwiftBetter），进一步探讨主题<br><br><br>每日精选高清题图，可做壁纸<br></div><br><div style="text-align: center"><br><img src="https://vernsu.github.io/images/wxqrcode.jpg" style="text-align: center;display: block;margin:auto;"><br></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/Swift-XML-XMLParser-RSS/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/Swift-XML-XMLParser-RSS/" itemprop="url">
                  iOS[Swift] 中 XML 解析与 RSS 阅读器的制作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-17T00:00:00+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了实践本文，抽时间给博客添加了 <a href="http://swift.diagon.me/rss.xml">RSS 订阅</a>，中间还遇到了<a href="http://swift.diagon.me/Hexo-RSS-Next-XML-feed-UTF-8/">各种问题</a>。 </p>
<h2 id="XML-解析"><a href="#XML-解析" class="headerlink" title="XML 解析"></a>XML 解析</h2><h3 id="XMLParser"><a href="#XMLParser" class="headerlink" title="XMLParser"></a>XMLParser</h3><p>XML 跟 JSON 一样，也是常用的的数据格式。苹果提供了 <code>XMLParser</code>类用来解析 XML 文档。</p>
<p><code>XMLParser</code>常用的两个方法，分别用来初始化和开始解析操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(data: <span class="type">Data</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<h3 id="XMLParserDelegate"><a href="#XMLParserDelegate" class="headerlink" title="XMLParserDelegate"></a>XMLParserDelegate</h3><p>对 XML 的解析实际上是实现 <code>XMLParserDelegate</code> 中的几个方法。<code>XMLParserDelegate</code>方法都是可选的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始解析时调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parserDidStartDocument</span><span class="params">(XMLParser)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 遇到一个开始标签时调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(XMLParser, didStartElement: String, namespaceURI: String?, qualifiedName: String?, attributes: [String : String] = [:])</span></span></div><div class="line"></div><div class="line"><span class="comment">// 遇到字符串时调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(XMLParser, foundCharacters: String)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 遇到结束标签时调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(XMLParser, didEndElement: String, namespaceURI: String?, qualifiedName: String?)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 成功完成解析时调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parserDidEndDocument</span><span class="params">(XMLParser)</span></span></div></pre></td></tr></table></figure>
<h2 id="解析-RSS"><a href="#解析-RSS" class="headerlink" title="解析 RSS"></a>解析 RSS</h2><h3 id="解析过程分析"><a href="#解析过程分析" class="headerlink" title="解析过程分析"></a>解析过程分析</h3><p>RSS 是一种内容分享格式规范，通常使用 XML 格式实现。观察本博客的<a href="http://swift.diagon.me/rss.xml">RSS</a>。发现每篇日志都包含在一个<code>&lt;item&gt;</code>闭合标签中，而一篇日志的三个要素，标题、日期、内容分别使用的标签为<code>&lt;title&gt;</code>,<code>&lt;pubDate&gt;</code>,<code>&lt;description&gt;</code>。我们在解析 XML 时保存这三块内容即可。</p>
<p>首先我们声明几个 property 存储当前的内容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currentElement = <span class="string">""</span> </div><div class="line"><span class="keyword">var</span> currentTitle = <span class="string">""</span></div><div class="line"><span class="keyword">var</span> currentDescription = <span class="string">""</span></div><div class="line"><span class="keyword">var</span> currentPubDate = <span class="string">""</span></div></pre></td></tr></table></figure>
<p>当<code>elementName</code>是 <code>&quot;item&quot;</code>时，说明接下来要解析该<code>&lt;item&gt;</code>包含的内容，即一篇独立的文章。这时候我们将标题、日期、内容 property 设置为空字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:])</span></span> &#123;</div><div class="line"></div><div class="line">  currentElement = elementName</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> currentElement == <span class="string">"item"</span> &#123;</div><div class="line">    currentTitle = <span class="string">""</span></div><div class="line">    currentDescription = <span class="string">""</span></div><div class="line">    currentPubDate = <span class="string">""</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来每遇到一个字符，将该字符追加到相应的 property 中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> parser: XMLParser, foundCharacters string: String)</span></span> &#123;</div><div class="line">  <span class="comment">/// Note: current string may only contain part of info.</span></div><div class="line">  <span class="keyword">switch</span> currentElement &#123;</div><div class="line">  <span class="keyword">case</span> <span class="string">"title"</span>:</div><div class="line">    currentTitle += string</div><div class="line">  <span class="keyword">case</span> <span class="string">"description"</span>:</div><div class="line">    currentDescription += string</div><div class="line">  <span class="keyword">case</span> <span class="string">"pubDate"</span>:</div><div class="line">    currentPubDate += string</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">break</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>标签<code>item</code>结束时生成该篇文章的 model，存入数组容器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rssItems = [(title: <span class="type">String</span>, description: <span class="type">String</span>, pubDate: <span class="type">String</span>)]()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> elementName == <span class="string">"item"</span> &#123;</div><div class="line">      <span class="keyword">let</span> rssItem = (title: currentTitle, description: currentDescription, pubDate: currentPubDate)</div><div class="line">      rssItems.append(rssItem)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析结束后更新 UI：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parserDidEndDocument</span><span class="params">(<span class="number">_</span> parser: XMLParser)</span></span> &#123;</div><div class="line">	<span class="comment">// update UI</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如遇解析错误，打印出来方便调试。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parser</span><span class="params">(<span class="number">_</span> parser: XMLParser, parseErrorOccurred parseError: Error)</span></span> &#123;</div><div class="line">  <span class="built_in">print</span>(parseError.localizedDescription)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>完整的项目代码点<a href="https://github.com/Vernsu/SwiftBlogDemo" target="_blank" rel="external">这里(Github)</a>下载。</p>
<hr>
<div style="text-align: center"><br>关注公众号（ID：SwiftBetter），进一步探讨主题<br><br><br>每日精选高清题图，可做壁纸<br></div><br><div style="text-align: center"><br><img src="https://vernsu.github.io/images/wxqrcode.jpg" style="text-align: center;display: block;margin:auto;"><br></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://swift.diagon.me/Hexo-RSS-Next-XML-feed-UTF-8/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="万恶胖为首">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Swift学徒">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Swift学徒" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/Hexo-RSS-Next-XML-feed-UTF-8/" itemprop="url">
                  Hexo 博客框架添加 RSS 订阅
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-16T00:00:00+08:00">
                2017-02-16
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>抽空给博客增加了 <a href="http://swift.diagon.me/rss.xml">RSS</a> 功能。</p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="安装-RSS-插件"><a href="#安装-RSS-插件" class="headerlink" title="安装 RSS 插件"></a>安装 RSS 插件</h3><p>在 blog 根目录下执行命令安装 RSS 插件: <a href="https://github.com/hexojs/hexo-generator-feed/" target="_blank" rel="external">hexo-generator-feed</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure>
<h3 id="配置-RSS-插件"><a href="#配置-RSS-插件" class="headerlink" title="配置 RSS 插件"></a>配置 RSS 插件</h3><p>编辑 Hexo 的配置文件 <code>_config.yml</code>，添加以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#RSS 订阅插件</div><div class="line">plugin:</div><div class="line">- hexo-generator-feed</div><div class="line">#RSS 插件配置</div><div class="line">feed:</div><div class="line">  type: rss2</div><div class="line">  path: rss.xml</div><div class="line">  limit: 20</div><div class="line">  hub:</div><div class="line">  content: true</div></pre></td></tr></table></figure>
<h3 id="主题开启-RSS-支持"><a href="#主题开启-RSS-支持" class="headerlink" title="主题开启 RSS 支持"></a>主题开启 RSS 支持</h3><p><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a> 主题，默认开启 RSS。其它主题请参考主题文档。</p>
<h3 id="生成-RSS"><a href="#生成-RSS" class="headerlink" title="生成 RSS"></a>生成 RSS</h3><p>执行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 重新生成博客文件并完成部署即可。 </p>
<h2 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h2><p>一切进行的这么的自然和谐，然而打开 RSS 页面的时候，What？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">This page contains the following errors:</div><div class="line">error on line 98 at column 35: Input is not proper UTF-8, indicate encoding !</div><div class="line">Bytes: 0x01 0xE9 0x92 0x88</div><div class="line">Below is a rendering of the page up to the first error.</div></pre></td></tr></table></figure>
<p>Google 了一番，很多中文用户都遇到了这个问题，但是并没有找到解决方案。</p>
<p>根据错误提示，用编辑器打开 <code>public</code> 目录下 的<code>rss.xml</code> 或 <code>atom.xml</code>。找到第98行35列，是这样的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;content type=&quot;html&quot;&gt;&lt;![CDATA[&lt;p&gt;</div></pre></td></tr></table></figure>
<p>继续 Google，找到了十四年前的一篇文章 <a href="https://coderanch.com/t/124970/Invalid-Character-CDATA" target="_blank" rel="external">Invalid Character inside CDATA</a>，大意就是 CDATA 里面的文本不能超出 UTF-8 字符集。</p>
<p>既然找到问题了，就有办法解决了。</p>
<ol>
<li><p>接着看错误信息，<code>Bytes</code> 这行，意思是在 <code>xml</code> 文件里有几个 <code>0x01</code> 字符。</p>
</li>
<li><p>编辑器打开 XML 文件，通过查找功能的正则匹配 <code>\x01</code>，果然找到了几个特殊字符。</p>
</li>
<li><p>然后打开对应文章的<code>.md</code>文档，找到相应的的位置，替换出问题的字符。</p>
</li>
<li><p>重新生成 rss.xml 并部署。</p>
</li>
<li><p>搞定。</p>
</li>
</ol>
<p>点击这里查看生成的 <a href="http://swift.diagon.me/rss.xml">RSS</a>。</p>
<p>然而，为什么会出现这种问题并不得而知。产生这个问题的原因可能是 Hexo 或者 Next 主题的 bug。</p>
<hr>
<div style="text-align: center"><br>关注公众号（ID：SwiftBetter），进一步探讨主题<br><br><br>每日精选高清题图，可做壁纸<br></div><br><div style="text-align: center"><br><img src="https://vernsu.github.io/images/wxqrcode.jpg" style="text-align: center;display: block;margin:auto;"><br></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="万恶胖为首" />
          <p class="site-author-name" itemprop="name">万恶胖为首</p>
          <p class="site-description motion-element" itemprop="description">笨办法学Swift</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/rss.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">万恶胖为首</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
